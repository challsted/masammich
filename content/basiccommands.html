<h2>Commands</h2>

<p>
This is part 2 of lesson 1 of my new lesson plan to help teach you to script in Shell.<br/>
These are just a small subset of the total number of commands you need to know in order to be able to do almost anything in linux<br/>
</p>

<ol>
	<li><a href="#cd">cd - Change Directory</a></li>
	<li><a href="#ls">ls - List Directorys</a></li>
	<li><a href="#man">man(ual) pages</a></li>
	<li><a href="#mkdir">mkdir - Make Directory</a></li>
	<li><a href="#rmdir">rmdir - Remove Directory</a></li>
	<li><a href="#rm">rm - Remove</a></li>
	<li><a href="#cp">cp - Copy</a></li>
	<li><a href="#mv">mv - Move &amp; how to rename files/folders</a></li>
	<li><a href="#find">find - Find files anywhere in your system</a></li>
	<li><a href="#grep">grep - A text grabber</a></li>
	<li><a href="#output">&gt; - output</a></li>
	<li><a href="#append">&gt;&gt; - append</a></li>
	<li><a href="#whereis">whereis - locate a file</a></li>
	<li><a href="#tail">tail - Follow a file that is being updated by another source</a></li>
	<li><a href="#less">less - Filters text to you 1 "screen" at a time</a></li>
	<li><a href="#clear">clear - Emptys your screen of text</a></li>
</ol>

<p>
Ok, so the links above link directly to each of the commands below for easier access. You can still read below like normal though. Each command will have a quick example of how to use it, and then if necessary a quick description of when to use it.<br/>
</p>
<hr width="50%">

<h3><strong id="cd"><em>cd</em></strong><br/></h3>
<p>
cd is use to "Change Directory"<br/>
You can also use "cd" to go back to your "home" if you just type "cd" and press enter. This is the same as typeing "<code class="codeInput">cd ~</code>" or typeing "<code class="codeInput">cd ~/home/userid</code>"<br/>
If you want to go back to the directory you came from, you can type <code class="codeInput">cd -</code><br/>
You have to pass cd a parameter inorder for it to know where you want to change directory to.<br/>
For example: <br/>
<code class="codeInput">cd /</code> will take you to the root directory of the system.<br/>
<code class="codeInput">cd ../</code> will take you back 1 directory<br/>
<code class="codeInput">cd ../../../../</code> will take you back 4 directorys (you can do this as few or as many times as you need)<br/>
<code class="codeInput">cd ~/git</code> will take you to a folder called "git" inside of your home directory.<br/>
You can also go back, then forward into a directory <code class="codeInput">cd ../../git/project</code> will go backwards 2 directorys, then forwards a directory.<br/>
</p>
<hr width="50%">

<h3><strong id="ls"><em>ls</em></strong><br/></h3>
<p>
list - Details coming soon<br/>

</p>
<hr width="50%">

<h3><strong id="man"><em>man</em>(ual) pages</strong></h3>
<p>
Man pages top this list because they are EXTREMELY helpful. They literally are the manual pages written by the people who made the tool. These are very under valued by many unfortunately, if you don't understand a command you can always read its man pages. So how do you get to them?
Use:<br/>
<code class="codeInput">man &lt;command&gt;</code><br/>
<code class="codeInput">man man </code>- Manual pages about the man command<br/>
<code class="codeInput">man ls</code><br/>
<code class="codeInput">man rm</code><br/>
<code class="codeInput">man dkpg</code><br/>
One thing you will notice, is sometimes there is multiple pages with different information. When this happens you will see a pop-up screen that asks "Which man page do you want" and it will have a number and/or letter in parentheses. So on my box right now, if i type:<br/>
<code class="codeInput">man vi</code><br/>
I get the following:<br/>
<code class="codeOutput">Man: find all matching manual pages</code><br/>
<code class="codeOutput">* vi (1)</code><br/>
<code class="codeOutput">vi (1p)</code><br/>
<code class="codeOutput">Man: What manual page do you want?</code><br/>
<code class="codeOutput">Man:</code><br/>
So I can enter 1, or 1p or just hit enter and the page with the * next to it will be auto selected.<br/>
</p>
<hr width="50%">

<h3><em><strong id="mkdir">mkdir</strong></em></h3><br/>
<p>
mkdir is used to "Make Directory" or make a folder ("d" in the first bit).<br/>
Use: <code class="codeInput">mkdir test</code>  - Make a directory called "test"<br/>
<code class="codeInput">mkdir -p zone/info/test/logs</code>   - This makes a directory called "zone" inside of that a directory called "info" inside of that a directory called "test" and inside of that a directory called "logs"<br/>
<code class="codeInput">mkdir test test2 folder random_word</code>  - Notice the spaces between words, this creates 4 directory's but not inside of each other with those names listed.<br/>
</p>
<hr width="50%">

<h3><em><strong id="rmdir">rmdir</strong></em></h3><br/>
<p>
rmdir removes a directory, but only if the directory is empty<br/>
Use:<br/>
<code class="codeInput">rmdir test</code><br/> - This will remove a directory called test. But ONLY if the directory is empty. 
</p>
<hr width="50%">

<h3><em><strong id="rm">rm</strong></em></h3><br/> 
<p>
Removes a file, it you try to use this to remove a folder, it will complain that it cannot. You can simply add a "-r" and it will remove folders. I only ever use rm, I never use rmdir personally. But rmdir is safer due to it checking to make sure the folder is empty before it deletes.<br/>
Use:<br/>
<code class="codeInput">rm file</code> - This deleted a file called "file"<br/>
<code class="codeInput">rm -r folder</code> - Does not check if its empty!<br/>
<code class="codeInput">rm -rf folder</code> - This does a "force" remove, it is highly unadvised to preform this action.
</p>
<hr width="50%">

<h3><em><strong id="cp">cp</strong></em></h3><br/> 
<p>
Copy, this is used to copy a file or folder from 1 place to another. With out any flags it will only copy the top-level if your copying folders. You need a -p (parents) if you want to copy everything inside of the folder also. It's also nice to use -v (verbose) if you want to actually see what is being copied.<br/>
Use:<br/>
<code class="codeInput">cp /home/user1/picture1 /home/user2/picture1</code> - This is copy picture l from user1's home directory to the home directory of user2 and leaving the name the same as it was originally. Leaving the original where it was.<br/>
<code class="codeInput">cp /home/user1/pictureABC /home/user2/pictureXYZ</code> - This copies the picture from user1's home directory, to the home directory of user 2, and changes the name of the picture. Leaving the original as it was.<br/>
<code class="codeInput">cp -p /home/user1/mystuff/ /home/user2/user1_stuff</code> - This copies the folder "mystuff" and everything inside of it also.<br/>
This is the time where useing -v is helpful so it would be better to type:<br/>
<code class="codeInput">cp -p -v /home/user1/mystuff/ /home/user2/user1_stuff</code> - This will copy everything inside of the folder, and print out everything that is being copied also. Otherwise it will just sit there for a while, while it copies and you have no idea whats going on.<br/>
</p>
<hr width="50%">

<h3><em><strong id="mv">mv &amp; rename</strong></em></h3><br/>
<p>
"mv" is simply short for "move", so if you want to move a file or folder from 1 place, you can use this command. Please note that the move command preserves permissions! So if you move a file that is owned by someone other than your account, you will also need to chown or chmod it sometimes.<br/>
Use:<br/>
<code class="codeInput">mv /etc/ssh/sshd_conf ~/.ssh/sshd.conf</code><br/>
"mv" is also used to rename a file, due to by default, there is no rename functionality. Simply move the file, don't change its directory (or do if that's what you need) and change the name of the file.<br/>
Use:<br/>
<code class="codeInput">mv fileoldname.txt filenewname.txt</code> - This will create simply remove the old file "fileoldname.txt" and give you that exact same file but with a new name "filenewname.txt"<br/>
</p>
<hr width="50%">

<h3><em><strong id="find">find</strong></em></h3><br/>
<p>
"find" is actually a very powerful tool, but can be kind of confusing. If you ever need to find a file, and you know some details about it, you can find it using this command. You can use the -name flag to give it an exact name, or even use -cmin to find files that were modified in the last X minutes.<br/>
Use:<br/>
<code class="codeInput">find / -name test.txt</code>  - This will find a file named test.txt anywhere on the computer.<br/>
<code class="codeInput">find . -name test2.txt</code>   - This will find a file in the current directory named test2.txt<br/>
<code class="codeInput">find . -iname test*.txt</code>  - This will find all files named test&lt;insert character&gt;.txt in the current directory<br/>
<code class="codeInput">find / -cmin 5</code>  - This will find all files that were "changed" in the last 5 minutes.<br/>
<code class="codeInput">find . -type f -perm 0777 -print</code> - This will find all files in the current directory with permissions "777" the 0 isn't important right now as its much more advanced.<br/>
</p>
<hr width="50%">

<h3><em><strong id="grep">grep</strong></em></h3><br/>
<p>
grep is one of my favorite tools, books can probably be written on practical uses of this amazing little word. Grep's exact use is to find lines of text matching a pattern. A little cryptic, I know, but that is probably due to HOW MUCH this little thing can do. Ill try to write a separate article about grep and how to use it more than what I'll list here. If you see a link HERE then it's created, if that's not a hyperlink yet. Then I haven't yet made the article. A few nice flags to know/use are the -v flag, which is "invert" and -n which gives a line number. Also, unlike find, you don't HAVE to use a flag to use grep.<br/>
Use:<br/>
<code class="codeInput">ifconfig | grep "up"</code>  - Searches for all of your Ethernet or wireless adapters and shows you the ones that are "up"<br/>
<code class="codeInput">grep "example 1" /</code>  - Searches EVERY FILE ON YOUR COMPUTER for the words "example 1" if it finds it, it will print it. (WARNING THIS IS VERY SLOW AND WILL TAKE A LONG TIME TO RUN)<br/>
<code class="codeInput">grep -i "string" textfile.txt</code>  - Searches the file "textfile.txt" for the term "string" but due to -i it will return things that don't match in case (so it will return String, sTring, STRING and so on)<br/>
<code class="codeInput">find ~/music -name "*.mp3" | grep -i "aqua" | grep -iv "remix"</code> - Ok so this one is a little complicated, but i can break it out for you. First it uses the <a href="#find">find</a> command (explained above) to find all files that end in .mp3 inside of your personal music folder. It then finds all files that end in .mp3, and have the word "aqua" in it with insensitive case (Aqua, AQUA and aqua will all return). Then it finds all files with the word "remix" and it removes them from your results, so you won't get all those German remixes of "Aqua - Barbie Girl". I actually use similar commands to this one my self.<br/>
<code class="codeInput">grep -n "function" program.c</code>  - This will find what ever function you give it in the program.c file, and it will also include a line number for every instance it finds. Why is this helpful? Well it's mostly helpful to coders, or admins who look though logs a lot. This will find a certain string and will give you the line number to go fix it. So if you compile your code and you see that a certain function isn't working, or if you need to find all 404's that hit your web server. You can find them easily!<br/>
</p>
<hr width="50%">

<h3><em><strong id="output">&gt; (output)</strong></em></h3><br/>
<p>
This is helpful when you need to output the results of something to a file. The actual command is just simply "&gt;".  From there you can grep for lines, or you can upload the results much more easier to github for review on a forum somewhere!<br/>
Use:<br/>
<code class="codeInput">ifconfig &gt; ifconfig.txt</code>  - This will make all of the text that would normally appear after typing "ifconfig" and put it into a text file called "ifconfig.txt".<br/>
<code class="codeInput">find / -name "*.php" &gt; php.txt | grep -i error</code>  - This will find all files that end in .php (useful on a web server of a server that has php installed and then puts the results into a php.txt file. It then finds everything in that file that has the word "error" spelled every possibly way (non-case sensitive).<br/>
</p>
<hr width="50%">

<h3><em><strong id="append">&gt;&gt; (Append)</strong></em></h3><br/>
<p>
This is helpful if you want to write something to the end of a file. So for example you can add a line or 2 or 3 or 4 to the end of a file with &gt;&gt;<br/>
Use:<br/>
<code class="codeInput">"Add This Line to the end" &gt;&gt; file.txt</code>  - This will add the line to the very end of the file "file.txt"<br/>
</p>
<hr width="50%">

<h3><em><strong id="whereis">whereis</strong></em></h3><br/>
<p>
whereis is simply 2 words "Where Is" then you give it a value to look for.<br/>
Use:<br/>
<code class="codeInput">whereis java</code>  - this will output the location of java on your machine, for me i get<br/>
<em>java: /etc/java /usr/share/java</em><br/>
<code class="codeInput">whereis grep</code> - this will output all of the locations of "grep" for me i get:<br/>
<em>grep: /bin/grep /usr/bin/grep /usr/share/man/man1/grep.1.gz /usr/share/man/man1p/grep.1p.gz</em><br/>
</p>
<hr width="50%">

<h3><em><strong id="tail">tail &amp; head</strong></em></h3><br/>
<p>
Tail and Head are cool commands if you want to see just the top or just the bottom of a file. You can pass both of them similar flags. -10 or -100 or -24 will show that number of lines. With tail you can use -f to "follow" the file (great for page files or log files that are being written to)<br/>
Use:<br/>
<code class="codeInput">head -20 error.log</code>  - This shows the top 20 lines of the error.log file.<br/>
<code class="codeInput">tail -100 error.log</code>  - This shows the bottom 100 lines of the file "error.log"<br/>
<code class="codeInput">tail -f error.log</code>  - This is something I use a lot to see errors as they are written. This is helpful because if you cat the file, or if you vi the file, you only get to see what it looks like from the moment you cat/opened it. -f will actually print new lines to the screen as they are written to the file.<br/>
</p>
<hr width="50%">

<h3><em><strong id="less">less</strong></em></h3><br/>
<p>
Less is kind of confusing term, but pretty nice if you need to output a TON of text to your screen and you want to actually read it. So for example, if you needed to output a huge file to your screen, you don't need to edit it/don't want to open in VI and you need to actually read it. You can cat the file, and pipe it to less like this:<br/>
<code class="codeInput">cat hugefileoftext.txt | less</code> - This will print 1 screen of text to your screen at a time, it will not move until you hit the "SPACE" key on your keyboard, which prints a full new screen of text, or you hit the "ENTER" key on your keyboard which prints only 1 new line to your screen (the bottom most line appears). Or if you hit "q" on your keyboard it will "quit" from the command.<br/>
</p>
<hr width="50%">

<h3><em><strong id="clear">clear</strong></em></h3><br/>
<p>
This is useful to "clear" your screen. It doesn't have any flags or do anything but exactly what it says. It "clears" the screen of anything that's on it (well the terminal you typed the command into).<br/>
Use:<br/>
<code class="codeInput">clear</code>  - Just a note, it doesn't actually delete or remove the text, simply scroll up in your terminal to see everything you "cleared".<br/>
</p>
<hr width="50%">