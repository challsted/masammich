<!DOCTYPE html>
<html lang="en">
<head>

	<meta charset="utf-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge">
  	<meta name="viewport" content="width=device-width, initial-scale=1">
  	<meta name="description" content="A homegrown blog about Linux and Learning">
    <meta name="author" content="Chase Hallsted">
	<title>Linux Commands</title>
	<!-- Bootstrap Core CSS -->
    <link type="text/css" rel="stylesheet" href="../css/bootstrap.min.css">
    <!-- Custom CSS -->
    <link type="text/css" rel="stylesheet" href="../css/clean-blog.min.css">
    <link type="text/css" rel="stylesheet" href="../css/custom.css">
    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- Custom Favicon -->
    <link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<script>
		$(function(){
			$('#header').load('../headfoot/header.html');
			$('#footer').load('../headfoot/footer.html');
		});
	</script>
	<script>
		jQuery(document).ready(function() {
		    var offset = 220;
		    var duration = 500;
		    jQuery(window).scroll(function() {
		        if (jQuery(this).scrollTop() > offset) {
		            jQuery('.back-to-top').fadeIn(duration);
		        } else {
		            jQuery('.back-to-top').fadeOut(duration);
		        }
		    });
		    
		    jQuery('.back-to-top').click(function(event) {
		        event.preventDefault();
		        jQuery('html, body').animate({scrollTop: 0}, duration);
		        return false;
		    })
		});
	</script>

</head>

<body>
	<div id="header"></div>
	<div class="content-container">

		<h3>Commands</h3>

		<!-- Convert to 3 or 4 column? -->

		<ol>
			<li><a href="#cd">cd</a></li>
			<li><a href="#ls">ls</a></li>
			<li><a href="#man">man(ual) pages</a></li>
			<li><a href="#mkdir">mkdir</a></li>
			<li><a href="#rmdir">rmdir</a></li>
			<li><a href="#rm">rm</a></li>
			<li><a href="#cp">cp</a></li>
			<li><a href="#mv">mv &amp; how to rename files/folders</a></li>
			<li><a href="#find">find</a></li>
			<li><a href="#grep">grep</a></li>
			<li><a href="#output">&gt; (output)</a></li>
			<li><a href="#append">&gt;&gt; (append)</a></li>
			<li><a href="#whereis">whereis</a></li>
			<li><a href="#tail">tail</a></li>
			<li><a href="#less">less</a></li>
			<li><a href="#clear">clear</a></li>
			<li><a href="#Ubuntu">Ubuntu Syntax</a></li>
			<li><a href="#arch">Arch Syntax</a></li>
		</ol>

		Ok, so the links above link directly to each of the commands below for easier access. You can still read below like normal though. Each command will have a quick example of how to use it, and then if necessary a quick description of when to use it.<br/>
		<hr width="50%">

		<h3><strong id="cd"><em>cd</em></strong><br/></h3>
		change directory - Details coming soon<br/>
		<hr width="50%">

		<h3><strong id="ls"><em>ls</em></strong><br/></h3>
		list - Details coming soon<br/>
		<hr width="50%">

		<h3><strong id="man"><em>man</em>(ual) pages</strong></h3> Man pages top this list because they are EXTREMELY helpful. They literally are the manual pages written by the people who made the tool. These are very under valued by many unfortunately, if you don't understand a command you can always read its man pages. So how do you get to them?

		Use:<br/>

		<code class="codeInput">man &lt;command&gt;</code><br/>

		<code class="codeInput">man man </code>- Manual pages about the man command<br/>

		<code class="codeInput">man ls</code><br/>

		<code class="codeInput">man rm</code><br/>

		<code class="codeInput">man dkpg</code><br/>

		One thing you will notice, is sometimes there is multiple pages with different information. When this happens you will see a pop-up screen that asks "Which man page do you want" and it will have a number and/or letter in parentheses. So on my box right now, if i type:<br/>

		<code class="codeInput">man vi</code><br/>

		I get the following:<br/>

		<code class="codeOutput">Man: find all matching manual pages</code><br/>
		<code class="codeOutput">* vi (1)</code><br/>
		<code class="codeOutput">vi (1p)</code><br/>
		<code class="codeOutput">Man: What manual page do you want?</code><br/>
		<code class="codeOutput">Man:</code><br/>
		So I can enter 1, or 1p or just hit enter and the page with the * next to it will be auto selected.<br/>
		<hr width="50%">

		<h3><em><strong id="mkdir">mkdir</strong></em></h3><br/>
		mkdir is used to "Make Directory" or make a folder ("d" in the first bit).<br/>

		Use: <code class="codeInput">mkdir test</code>  - Make a directory called "test"<br/>

		<code class="codeInput">mkdir -p zone/info/test/logs</code>   - This makes a directory called "zone" inside of that a directory called "info" inside of that a directory called "test" and inside of that a directory called "logs"<br/>

		<code class="codeInput">mkdir test test2 folder random_word</code>  - Notice the spaces between words, this creates 4 directory's but not inside of each other with those names listed.<br/>
		<hr width="50%">

		<h3><em><strong id="rmdir">rmdir</strong></em></h3><br/>
		rmdir removed a directory, but only if the directory is empty<br/>

		Use:<br/>

		<code class="codeInput">rmdir test</code><br/>
		<hr width="50%">

		<h3><em><strong id="rm">rm</strong></em></h3><br/> 
		Removes a file, it you try to use this to remove a folder, it will complain that it cannot. You can simply add a "-r" and it will remove folders. I only ever use rm, i never use rmdir personally. But rmdir is safer due to it checks to make sure the folder is empty before it deletes.<br/>

		Use:<br/>

		<code class="codeInput">rm file</code>   - The "delete of the Linux world"<br/>

		<code class="codeInput">rm -r folder</code>   - Does not check if its empty!<br/>
		<hr width="50%">

		<h3><em><strong id="cp">cp</strong></em></h3><br/> 
		Copy, this is used to copy a file or folder from 1 place to another. With out any flags it will only copy the top-level if your copying folders. You need a -p (parents) if you want to copy everything inside of the folder also. It's also nice to use -v (verbose) if you want to actually see what is being copied.<br/>

		Use:<br/>

		<code class="codeInput">cp /home/user1/picture1 /home/user2/picture1</code> - This is Copy picture l from user1's home directory to the home directory of user2 and leaving the name the same as it was originally. Leaving the original where it was.<br/>

		<code class="codeInput">cp /home/user1/pictureABC/ /home/user2/pictureXYZ/</code> - This copy's the picture from user1's home directory, to the home directory of user 2, and changes the name of the picture. Leaving the original as it was.<br/>

		<code class="codeInput">cp -p /home/user1/mystuff/ /home/user2/user1_stuff</code> - This copys the folder "mystuff" and everything inside of it also.<br/>

		This is the time where useing -v is helpful so it would be better to type:<br/>

		<code class="codeInput">cp -p -v /home/user1/mystuff/ /home/user2/user1_stuff</code> - This will copy everything inside of the folder, and print out everything that is being copied also. Other wise it will just sit there for a while, while it copy's and you have no idea whats going on.<br/>
		<hr width="50%">

		<h3><em><strong id="mv">mv &amp; rename</strong></em></h3><br/>

		"mv" is simply short for "move", so if you want to move a file or folder from 1 place, you can use this command. Please note that the move command preserves permissions! So if you move a file that is owned by someone other than your account, you will also need to <a href="http://masammich.wordpress.com/2014/03/27/linux-permissions/#s2">chown or chmod</a> it sometimes.<br/>

		Use:<br/>

		mv /etc/ssh/sshd_conf ~/.ssh/sshd.conf<br/>

		"mv" is also used to rename a file, due to by default, there is no rename functionality. Simply move the file, don't change its directory (or do if that's what you need) and change the name of the file.<br/>

		Use:<br/>

		mv fileoldname.txt filenewname.txt  - This will create simply remove the old file "fileoldname.txt" and give you that exact same file but with a new name "filenewname.txt"<br/>
		<hr width="50%">

		<h3><em><strong id="find">find</strong></em></h3><br/>

		"find" is actually a very powerful tool, but can be kind of confusing. If you ever need to find a file, and you know some details about it, you can find it using this command. You can use the -name flag to give it an exact name, or even use -cmin  to find files that were modified in the last X minutes.<br/>

		Use:<br/>

		<code class="codeInput">find / -name test.txt</code>  - This will find a file named test.txt anywhere on the computer.<br/>

		<code class="codeInput">find . -name test2.txt</code>   - This will find a file in the current directory named test2.txt<br/>

		<code class="codeInput">find . -iname test*.txt</code>  - This will find all files named test&lt;insert character&gt;.txt in the current directory<br/>

		<code class="codeInput">find / -cmin 5</code>  - This will find all files that were "changed" in the last 5 minutes.<br/>

		<code class="codeInput">find . -type f -perm 0777 -print</code> - This will find all files in the current directory with permissions "777" the 0 isn't important right now its much more advanced.<br/>
		<hr width="50%">

		<h3><em><strong id="grep">grep</strong></em></h3><br/>

		grep is one of my favorite tools, books can probably be written on practical uses of this amazing little word. Grep's exact use is to find lines of text matching a pattern. A little cryptic, I know, but that is probably due to HOW MUCH this little thing can do. Ill try to write a separate article about grep and how to use it more than what ill list here. If you see a link HERE then it's created, if that's not a hyperlink yet. Then i haven't yet made the article. A few nice flags to know/use are the -v flag, which is "invert" and -n which gives a line number. Also, unlike find, you don't HAVE to use a flag to use grep.<br/>

		Use:<br/>

		<code class="codeInput">ifconfig | grep "up"</code>  - Searches for all of your Ethernet or wireless adapters and shows you the ones that are "up"<br/>

		<code class="codeInput">grep "example 1" /</code>  - Searches EVERY FILE ON YOUR COMPUTER for the words "example 1" if it finds it, it will print it. (WARNING THIS IS VERY SLOW AND WILL TAKE A LONG TIME TO RUN)<br/>

		<code class="codeInput">grep -i "string" textfile.txt</code>  - Searches the file "textfile.txt" for the term "string" but due to -i it will return things that don't match in case (so it will return String, sTring, STRING and so on)<br/>

		<code class="codeInput">find ~/music -name "*.mp3" | grep -i "aqua" | grep -iv "remix"</code> - Ok so this one is a little complicated, but i can break it out for you. First it uses the <a href="#find">find</a> command (explained above) to find all files that end in .mp3 inside of your personal music folder. It then finds all files that end in .mp3, and have the word "aqua" in it with insensitive case (Aqua, AQUA and aqua will all return). Then it finds all files with the word "remix" and it removes them from your results, so you wont get all those German remixes of "Aqua - Barbie Girl". I actually use similar commands to this one my self.<br/>

		<code class="codeInput">grep -n "function" program.c</code>  - This will find what ever function you give it in the program.c file, and it will also include a line number for every instance it finds. Why is this helpful? Well it's mostly helpful to coders, or admins who look though logs a lot. This will find a certain string and will give you the line number to go fix it. So if you compile your code and you see that a certain function isn't working, or if you need to find all 404's that hit your web server. You can find them easily!<br/>
		<hr width="50%">

		<h3><em><strong id="output">&gt; (output)</strong></em></h3><br/>

		This is helpful when you need to output the results of something to a file. The actual command is just simply "&gt;".  From there you can grep for lines, or you can upload the results much more easier to github for review on a forum somewhere!<br/>

		Use:<br/>

		<code class="codeInput">ifconfig &gt; ifconfig.txt</code>  - This will make all of the text that would normally appear after typing "ifconfig" and put it into a text file called "ifconfig.txt".<br/>

		<code class="codeInput">find / -name "*.php" &gt; php.txt | grep -i error</code>  - This will find all files that end in .php (useful on a web server of a server that has php installed and then puts the results into a php.txt file. It then finds everything in that file that has the word "error" spelled every possibly way (non-case sensitive).<br/>
		<hr width="50%">

		<h3><em><strong id="append">&gt;&gt; (Append)</strong></em></h3><br/>

		This is helpful if you want to write something to the end of a file. So for example you can add a line or 2 or 3 or 4 to the end of a file with &gt;&gt;<br/>

		Use:<br/>

		<code class="codeInput">"Add This Line to the end" &gt;&gt; file.txt</code>  - This will add the line to the very end of the file "file.txt"<br/>
		<hr width="50%">

		<h3><em><strong id="whereis">whereis</strong></em></h3><br/>

		whereis is simply 2 words "Where Is" then you give it a value to look for.<br/>

		Use:<br/>

		<code class="codeInput">whereis java</code>  - this will output the location of java on your machine, for me i get<br/>

		<em>java: /etc/java /usr/share/java</em><br/>

		<code class="codeInput">whereis grep</code> - this will output all of the locations of "grep" for me i get:<br/>

		<em>grep: /bin/grep /usr/bin/grep /usr/share/man/man1/grep.1.gz /usr/share/man/man1p/grep.1p.gz</em><br/>
		<hr width="50%">

		<h3><em><strong id="tail">tail &amp; head</strong></em></h3><br/>

		Tail and Head are cool commands if you want to see just the top or just the bottom of a file. You can pass both of them similar flags. -10 or -100 or -24 will show that number of lines. With tail you can use -f to "follow" the file (great for page files or log files that are being written to)<br/>

		Use:<br/>

		<code class="codeInput">head -20 error.log</code>  - This shows the top 20 lines of the error.log file.<br/>

		<code class="codeInput">tail -100 error.log</code>  - This shows the bottom 100 lines of the file "error.log"<br/>

		<code class="codeInput">tail -f error.log</code>  - This is something I use a lot to see errors as they are written. This is helpful because if you cat the file, or if you vi the file, you only get to see what it looks like from the moment you cat/opened it. -f will actually print new lines to the screen as they are written to the file.<br/>
		<hr width="50%">

		<h3><em><strong id="less">less</strong></em></h3><br/>

		Less is kind of confusing term, but pretty nice if you need to output a TON of text to your screen and you want to actually read it. So for example, if you needed to output a huge file to your screen, you don't need to edit it/don't want to open in VI and you need to actually read it. You can cat the file, and pipe it to less like this:<br/>

		<code class="codeInput">cat hugefileoftext.txt | less</code> - This will print 1 screen of text to your screen at a time, it will not move until you hit the "SPACE" key on your keyboard, which prints a full new screen of text, or you hit the "ENTER" key on your keyboard which prints only 1 new line to your screen (the bottom most line appears). Or if you hit "q" on your keyboard it will "quit" from the command.<br/>
		<hr width="50%">

		<h3><em><strong id="clear">clear</strong></em></h3><br/>

		This is useful to "clear" your screen. It doesn't have any flags or do anything but exactly what it says. It "clears" the screen of anything that's on it (well the terminal you typed the command into).<br/>

		Use:<br/>

		<code class="codeInput">clear</code>  - Just a note, it doesn't actually delete or remove the text, simply scroll up in your terminal to see everything you "cleared".<br/>
		<hr width="50%">

		<h3><em><strong id="Ubuntu">Ubuntu Syntax</strong></em></h3><br/>
		So Ubuntu, and Ubuntu's offspring (like Linux Mint) all share similar syntax when it comes to a lot of the commonly used commands. When I write articles, I usually try to include an Ubuntu source if i can find one so you that use Ubuntu can also play along.<br/>

		<em><strong>So before we can start, you need to know 2 things.</strong></em><br/>
		1) <em>What is "<code class="codeInput">sudo</code>" and why should I always be careful when using it?</em><br/>
		2) <em>What is "<code class="codeInput">apt-get</code>"?</em><br/>

		<em><strong>To answer the first part,</strong></em> sudo is short for "Super User DO". What does that mean? Super user is like an admin, the super user (known as the root account) has permissions to do anything to anyones stuff on the whole computer no matter what you say about it (yes, this can be curbed/thwarted). So when you type "sudo" your telling the CLI that the next thing you type (everything after it) will be done with super user powers. So "sudo cd .." is kind of dumb, why move backwards a directory using super user powers? But "sudo apt-get install vlc" is necessary due to your telling the computer to use the super user account to install a program called VLC, and that will require system wide changes!<br/>
		So to summarize, "<code class="codeInput">sudo</code>" is simply a short word for when you want to do something, with admin powers, but not use an admin account.<br/>

		<em><strong>To answer the second part.</strong></em> "apt-get" is the short name of the "package-manager" in Ubuntu (well, for Debian based OS's... ill cover this later). "aptitude get" was the original syntax but you can simply type "apt-get" now. "Aptitude" is the full name, your telling aptitude to get what ever package your telling it to. Whether it be to install, remove, or add a repository, it's all done though getting information with aptitude!<br/>

		<strong><em>So, now that that's out of the way.</em> </strong><br/>

		If you want to install something in Ubuntu, you are going to need to use sudo (super user do) powers, your also going to need to call upon aptitude to get a package, and your going to need to tell aptitude what to do with that package, and what the name of the package you're looking for is called

		So, lets give it a shot, lets say you want to install "VLC" which is an awesome light weight, open source media player. Supports a lot of different codex's out of the box and just works well on very little resources. You will need to type:<br/>
		<code class="codeInput">sudo apt-get install vlc</code><br/>

		Lets go over that really fast again:<br/>
		<code class="codeInput">sudo</code>, we know what that does now kind of, were using the super user account to do something.<br/>
		<code class="codeInput">apt-get</code>, ok were using the built-in package manager to do something else<br/>
		<code class="codeInput">install</code>, ok, were using aptitude to install..<br/>
		<code class="codeInput">vlc</code>, a package named "vlc"<br/>

		Ok, so it asks you for a password! Is it safe to type in your password? What password do you use?<br/>
		You use your local computer password, so if you logged in with the password "fubar" then you use the password "fubar" now.<br/>

		<em><strong>OMG A BUNCH OF TEXT!</strong> </em><br/>
		This is perfectly ok and normal, just stay calm, assuming you typed everything ok, and your password was correct, apt-get is now doing all the heavy lifting for you, it's going out, finding the package you requested in its repositories, and its also looking at the package and asking it what else it needs to install. It then checks your computer, and sees what packages you do not have that the package you requested needs. It then presents to you a "(Y/n)?" prompt that is asking you "Do you want to install the above packages? You can enter Y for yes or N for no, or just hit enter, because the "Y" is capital in this prompt, Y is the default. It will then do the heavy  lifting again and download and install the package, and all of its dependencies it needs for you. When it done, it will sit there and wait for the next command you want to give it.<br/>

		<strong>So, just for a quick comparison:</strong><br/>
		<strong>In Linux</strong> you opened a terminal, you typed 1 command (<code class="codeInput">sudo apt-get install vlc</code>) then typed your password, waited a second or two, hit the enter key to accept the download, then waited again and its done. You now have VLC installed and (hopefully) fully functional on your computer!<br/>
		If you were to do this same thing <strong>in windows</strong>, you would have to open a browser, go to your favorite search engine (or use a search tool bar (<em>shudder....</em>) type in "vlc" then using what ever search engine you choose search though possibly many hundreds of millions of links, hoping that the top result is the one you want. You then look around the website for a "downloads" button or something of that nature, you download it and hope it's not filled with virus's. You then wait for your virus scanner to scan the package for known virus's, you then open up your downloads folder, double-click the vlc.exe icon, next, next, next finish though the install prompt, then open your start menu and you have VLC installed on your computer! <br/>Congratulations!<br/>

		See how much simpler this is on Linux??? This is just 1 example, I have more!<br/>

		<em><strong>So now lets uninstall a package! </strong></em><br/>

		The command is: <code class="codeInput">sudo apt-get remove</code> &lt;package&gt;, so for our example, lets use the vlc package we just installed. You don't have to do this, just as an example.<br/>

		<code class="codeInput">sudo apt-get remove vlc</code><br/>

		It will go though, find VLC's package, and remove it from where it was installed.<br/>

		Now, if you want to 100% remove a package, you can use something called a "flag" to assist you. If you were using vlc, you changed settings, you had all kinds of themes installed into it and special features and fancy stuff all over your desktop. Then you might need to do this instead. Due to sometimes if all you do is remove VLC, it will not remove the other packages that look for vlc/rely on VLC.<br/>

		<code class="codeInput">sudo apt-get --purge remove vlc</code><br/>

		This will purge all settings, and dependency that it had (that your computer doesn't need for other things)<br/>

		<em><strong>Ok, last thing I want to tell you about Ubuntu is PPA's</strong></em><br/>

		PPA (Personal Package Archive) is a neat little way to get software that Ubuntu would not normally support, and keep it up-to-date though the package manager! So if you're trying to install a piece of software, that Ubuntu does not natively support, or maybe a version of a piece of software that Ubuntu doesn't have in their repository. Then  you would use a PPA.<br/>

		So for example, Ubuntu does not have the Cinnamon Desktop located in their repository's. So you search the internet and you find this:<br/>

		<code class="codeInput">sudo add-apt-repository ppa:gwendal-lebihan-dev/cinnamon-stable</code><br/>

		We can dissect this and find out what it is actually doing/saying.<br/>

		So, the first part, we already understand "sudo", then its doing something we kind of understand, but not quite. Its calling "apt" but instead of "apt-get" its saying "add-apt" what is that? This is adding something TO apt, aka, it's adding a place for apt to look at to check for software and updates.<br/>
		So what is it adding? Its adding a repository: "add-apt-repository". Ok, so were using super user to add a repo to apt. Got it. Next!<br/>

		Ok so next is "ppa:" this is telling apt that its adding a ppa with the following name. In this case its "gwendal-lebihan-dev/cinnamon-stable" that is just how it is identified on launchpad. Launchpad is where these ppa's are hosted and where apt goes to look for them. So if you entered the above command, it would tell apt, to look for that software.<br/>

		So lets create another little example. Lets assume that you have not added the ppa shown above.<br/>

		You want to install "cinnamon" to your desktop. That's easy, you just need to type:

		<code class="codeInput">sudo apt-get install cinnamon</code><br/>

		But guess what, apt has no idea what cinnamon is! So it returns that there was no package found with that name.<br/>

		So you go and you find the ppa above, you enter it into terminal, and then you run an update so:<br/>

		<code class="codeInput">sudo add-apt-repository ppa:gwendal-lebihan-dev/cinnamon-stable</code><br/>

		Now you need to do an "update", this is easy just run<br/>

		<code class="codeInput">sudo apt-get update</code><br/>

		Now apt knows about the repository that cinnamon is located at. So, now if you type "sudo apt-get install cinnamon" it will see that repository and install as it like normal!<br/>
		<hr width="50%">

		<h3><em><strong id="arch">Arch Syntax</strong></em></h3><br/>
		For the Arch CLI I wont go into extreme details like i did with the Ubuntu, I expect you to understand basic stuff once it's explained.<br/>

		All of the following are run as root or using sudo:<br/>

		<code class="codeInput">pacman -S </code>&lt;pkg&gt;<br/>
		- This installs a package<br/>

		<code class="codeInput">pacman -Ss </code>&lt;pkg&gt;<br/>
		- This searches for a package<br/>

		<code class="codeInput">pacman -R </code>&lt;pkg&gt;<br/>
		- Removes said package<br/>

		<code class="codeInput">pacman -Rns </code>&lt;pkg&gt;<br/>
		- This removes the package, the dependency's, and the config files<br/>

		<code class="codeInput">pacman -Syu </code>&lt;pkg&gt;<br/>
		- This does a full system update and re-syncs the package lists<br/>

		<em><strong>Now, a quick guide on how to install from the AUR.</strong></em><br/>
		So lets say you get a package off of the AUR, you download the PACKAGEBUILD and its sitting in your ~/Downloads folder. You untar and uncompress it with the following:<br/>

		<code class="codeInput">tar -zxvf </code>&lt;file.tar.gz&gt;<br/>

		This will "untar" and "unzip" the file, now you need to cd to the dir that was created.<br/>

		<code class="codeInput">cd </code>&lt;file&gt;<br/>

		Now you need to make the package, the easiest way is to run<br/>

		<code class="codeInput">makepkg -s</code><br/>

		This works about 75% of the time, it resolves the dependency's for the package and installs them. This is only a problem if one of the dependency are also only found in the AUR. If that's the case you must go out and find those dependency's (usually listed under the appropriate column in the AUR). So assuming you now have all of the dependency installed you'll see a long ass string of code as the packages are compiled and then it will spit out a  you need to run:<br/>

		<code class="codeInput">pacman -U </code>&lt;file.tar.xz&gt;<br/>

		This will actually install the file using pacman.<br/>

		Good luck with Arch!<br/>

	</div>

    <!-- Footer -->
    <div id="footer"></div>
    <!-- jQuery -->
    <script src="../../js/jquery.js"></script>
    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.min.js"></script>
    <!-- Custom Theme JavaScript -->
    <script src="../../js/clean-blog.min.js"></script>
</body>
</html>